/**
 * Unified Call Event Model
 *
 * This module defines a common CallEvent type that normalizes the different
 * event formats from Telnyx and SignalWire into a single consistent structure.
 * This abstraction allows the application to handle call events uniformly
 * regardless of which telephony provider is being used.
 *
 * @module providers/call-event.model
 */

// ============================================================================
// Call Event Types Enum
// ============================================================================

/**
 * Standardized call event types across all providers
 *
 * These represent the key lifecycle events for a phone call:
 * - initiated: Call request sent to provider, dialing has begun
 * - ringing: Call is ringing at the destination
 * - answered: Call was answered (human or machine)
 * - completed: Call ended normally
 * - failed: Call failed to connect (error, invalid number, etc.)
 */
export enum CallEventType {
  /** Call request sent to provider, dialing has begun */
  INITIATED = 'initiated',
  /** Call is ringing at the destination */
  RINGING = 'ringing',
  /** Call was answered (human or machine) */
  ANSWERED = 'answered',
  /** Call ended normally */
  COMPLETED = 'completed',
  /** Call failed to connect */
  FAILED = 'failed'
}

// ============================================================================
// Call Direction
// ============================================================================

/**
 * Direction of the call
 */
export enum CallDirection {
  /** Outbound call initiated by the application */
  OUTBOUND = 'outbound',
  /** Inbound call received by the application */
  INBOUND = 'inbound'
}

// ============================================================================
// Hangup Reason
// ============================================================================

/**
 * Reason why the call ended
 */
export enum HangupReason {
  /** Normal call clearing - call ended normally */
  NORMAL = 'normal',
  /** Caller hung up */
  CALLER_HANGUP = 'caller_hangup',
  /** Callee hung up */
  CALLEE_HANGUP = 'callee_hangup',
  /** No answer within timeout */
  NO_ANSWER = 'no_answer',
  /** Destination was busy */
  BUSY = 'busy',
  /** Call was rejected */
  REJECTED = 'rejected',
  /** Call was cancelled before answer */
  CANCELLED = 'cancelled',
  /** Call failed due to error */
  ERROR = 'error',
  /** Machine/voicemail detected (AMD) */
  MACHINE_DETECTED = 'machine_detected',
  /** Unknown reason */
  UNKNOWN = 'unknown'
}

// ============================================================================
// AMD Result
// ============================================================================

/**
 * Answering Machine Detection result
 */
export enum AMDResult {
  /** Human answered the call */
  HUMAN = 'human',
  /** Machine/voicemail detected */
  MACHINE = 'machine',
  /** Fax machine detected */
  FAX = 'fax',
  /** Detection was inconclusive */
  UNKNOWN = 'unknown',
  /** AMD not enabled or not yet detected */
  NOT_DETECTED = 'not_detected'
}

/**
 * AMD detection result with confidence score
 *
 * This interface provides both the detection result and the provider's
 * confidence level in that detection.
 */
export interface AMDDetectionResult {
  /**
   * The detected result type
   */
  result: AMDResult;

  /**
   * Confidence score from 0.0 to 1.0
   * - 1.0 = 100% confident
   * - 0.5 = 50% confident
   * - undefined = provider doesn't provide confidence
   */
  confidence?: number;

  /**
   * The raw result value from the provider
   * Preserved for debugging and logging
   */
  rawResult?: string;

  /**
   * Additional AMD-related metadata from the provider
   */
  metadata?: {
    /**
     * Detection method used (e.g., 'tone_analysis', 'silence_detection')
     */
    method?: string;

    /**
     * Duration of audio analyzed before detection (in milliseconds)
     */
    analysisDurationMs?: number;

    /**
     * Whether the detection was performed by the provider
     * (vs. manually specified)
     */
    automated?: boolean;
  };
}

// ============================================================================
// Call Event Interface
// ============================================================================

/**
 * Unified call event structure
 *
 * This interface normalizes events from different telephony providers
 * (Telnyx, SignalWire) into a consistent format that the application
 * can process uniformly.
 */
export interface CallEvent {
  /**
   * Unique identifier for this event
   * Generated by the provider or by the mapper
   */
  eventId: string;

  /**
   * Type of call event
   */
  eventType: CallEventType;

  /**
   * Provider-specific call identifier
   * - Telnyx: call_control_id
   * - SignalWire: CallSid
   */
  callId: string;

  /**
   * Provider-specific session identifier (if available)
   * - Telnyx: call_session_id
   * - SignalWire: May not have separate session ID
   */
  sessionId?: string;

  /**
   * Current call status as a normalized string
   * This may include more granular statuses than eventType
   */
  status: string;

  /**
   * Timestamp when the event occurred
   */
  timestamp: Date;

  /**
   * Direction of the call
   */
  direction: CallDirection;

  /**
   * Phone number that initiated the call (E.164 format)
   */
  from: string;

  /**
   * Phone number that received the call (E.164 format)
   */
  to: string;

  /**
   * Name of the telephony provider
   */
  provider: 'telnyx' | 'signalwire';

  /**
   * Call duration in seconds (available after call ends)
   */
  durationSecs?: number;

  /**
   * Reason the call ended (available for COMPLETED/FAILED events)
   */
  hangupReason?: HangupReason;

  /**
   * AMD detection result (if AMD was enabled)
   */
  amdResult?: AMDResult;

  /**
   * AMD detection confidence score (0.0 to 1.0)
   * Higher values indicate greater confidence in the detection
   */
  amdConfidence?: number;

  /**
   * Detailed AMD detection information (if available)
   * Includes confidence score, raw result, and metadata
   */
  amdDetectionDetails?: AMDDetectionResult;

  /**
   * Recording URL (if recording was enabled and is available)
   */
  recordingUrl?: string;

  /**
   * Additional metadata from the provider
   * Use this for provider-specific data that doesn't fit the standard fields
   */
  metadata?: Record<string, unknown>;

  /**
   * The original raw event from the provider
   * Preserved for debugging and logging purposes
   */
  rawEvent?: unknown;
}

// ============================================================================
// Telnyx Raw Event Types
// ============================================================================

/**
 * Telnyx webhook event wrapper structure
 */
export interface TelnyxWebhookEvent {
  data: {
    event_type: string;
    id: string;
    occurred_at: string;
    payload: TelnyxCallPayload;
    record_type: string;
  };
}

/**
 * Telnyx call event payload structure
 */
export interface TelnyxCallPayload {
  call_control_id: string;
  call_leg_id?: string;
  call_session_id?: string;
  to: string;
  from: string;
  direction?: string;
  state?: string;
  hangup_cause?: string;
  hangup_source?: string;
  result?: string;
  machine_detection_result?: string;
  /**
   * AMD confidence score (if provided by Telnyx)
   * Range: 0.0 to 1.0
   */
  machine_detection_confidence?: number;
  recording_urls?: {
    mp3?: string;
    wav?: string;
  };
  public_recording_urls?: {
    mp3?: string;
    wav?: string;
  };
  recording_duration?: number;
}

// ============================================================================
// SignalWire Raw Event Types
// ============================================================================

/**
 * SignalWire status callback payload structure
 */
export interface SignalWireCallbackPayload {
  CallSid: string;
  CallStatus: string;
  From: string;
  To: string;
  Direction: string;
  AccountSid?: string;
  ApiVersion?: string;
  CallDuration?: string;
  Timestamp?: string;
  HangupBy?: string;
  RecordingUrl?: string;
  RecordingSid?: string;
  RecordingDuration?: string;
  /**
   * AMD result from SignalWire (if AMD was enabled)
   * Values: 'human', 'machine', 'fax', 'unknown'
   */
  AnsweringMachineResult?: string;
  /**
   * AMD confidence score from SignalWire (if available)
   * Range: 0 to 100
   */
  AnsweringMachineConfidence?: number;
}

// ============================================================================
// Mapper Functions
// ============================================================================

/**
 * Map Telnyx event type to unified CallEventType
 *
 * @param telnyxEventType - The Telnyx event_type string
 * @returns The unified CallEventType
 */
function mapTelnyxEventType(telnyxEventType: string): CallEventType {
  switch (telnyxEventType) {
    case 'call.initiated':
      return CallEventType.INITIATED;
    case 'call.ringing':
      return CallEventType.RINGING;
    case 'call.answered':
      return CallEventType.ANSWERED;
    case 'call.hangup':
    case 'call.machine.detection.ended':
    case 'call.recording.saved':
      return CallEventType.COMPLETED;
    case 'call.failed':
      return CallEventType.FAILED;
    default:
      // For unknown events, try to infer from context
      if (telnyxEventType.includes('hangup') || telnyxEventType.includes('ended')) {
        return CallEventType.COMPLETED;
      }
      return CallEventType.INITIATED; // Default fallback
  }
}

/**
 * Map Telnyx hangup cause to unified HangupReason
 *
 * @param hangupCause - The Telnyx hangup_cause string
 * @param hangupSource - The Telnyx hangup_source string
 * @returns The unified HangupReason
 */
function mapTelnyxHangupReason(hangupCause?: string, hangupSource?: string): HangupReason {
  // Check hangup source first
  if (hangupSource === 'caller') {
    return HangupReason.CALLER_HANGUP;
  }
  if (hangupSource === 'callee') {
    return HangupReason.CALLEE_HANGUP;
  }

  // Map hangup cause
  if (!hangupCause) {
    return HangupReason.UNKNOWN;
  }

  switch (hangupCause.toLowerCase()) {
    case 'normal_clearing':
    case 'normal_call_clearing':
      return HangupReason.NORMAL;
    case 'no_answer':
    case 'no_user_response':
      return HangupReason.NO_ANSWER;
    case 'user_busy':
    case 'busy':
      return HangupReason.BUSY;
    case 'call_rejected':
    case 'rejected':
      return HangupReason.REJECTED;
    case 'originator_cancel':
    case 'cancelled':
      return HangupReason.CANCELLED;
    case 'unallocated_number':
    case 'invalid_number_format':
    case 'network_out_of_order':
      return HangupReason.ERROR;
    default:
      return HangupReason.UNKNOWN;
  }
}

/**
 * Map Telnyx direction to unified CallDirection
 *
 * @param telnyxDirection - The Telnyx direction string
 * @returns The unified CallDirection
 */
function mapTelnyxDirection(telnyxDirection?: string): CallDirection {
  if (!telnyxDirection) {
    return CallDirection.OUTBOUND; // Default for outbound dialer app
  }
  return telnyxDirection.toLowerCase() === 'incoming'
    ? CallDirection.INBOUND
    : CallDirection.OUTBOUND;
}

/**
 * Map a Telnyx webhook event to a unified CallEvent
 *
 * @param telnyxEvent - The raw Telnyx webhook event
 * @returns The normalized CallEvent
 *
 * @example
 * ```typescript
 * const telnyxWebhook = {
 *   data: {
 *     event_type: 'call.answered',
 *     id: 'evt-123',
 *     occurred_at: '2024-01-15T10:30:00Z',
 *     payload: {
 *       call_control_id: 'cc-456',
 *       to: '+12025551234',
 *       from: '+12025559999',
 *       direction: 'outgoing'
 *     }
 *   }
 * };
 *
 * const callEvent = mapTelnyxEventToCallEvent(telnyxWebhook);
 * console.log(callEvent.eventType); // 'answered'
 * console.log(callEvent.callId); // 'cc-456'
 * ```
 */
// ============================================================================
// AMD Mapper Functions
// ============================================================================

/**
 * Map Telnyx AMD result to unified AMDDetectionResult
 *
 * @param telnyxResult - The Telnyx machine_detection_result string
 * @param telnyxConfidence - The Telnyx machine_detection_confidence number (optional)
 * @returns The unified AMDDetectionResult
 *
 * @example
 * ```typescript
 * const amdResult = mapTelnyxAmdResult('human', 0.95);
 * console.log(amdResult.result); // 'human'
 * console.log(amdResult.confidence); // 0.95
 * ```
 */
export function mapTelnyxAmdResult(
  telnyxResult: string | undefined,
  telnyxConfidence?: number
): AMDDetectionResult | undefined {
  if (!telnyxResult) {
    return undefined;
  }

  const normalizedResult = telnyxResult.toLowerCase().trim();
  let result: AMDResult;

  switch (normalizedResult) {
    case 'human':
      result = AMDResult.HUMAN;
      break;
    case 'machine':
    case 'voicemail':
    case 'am':
    case 'amd':
      result = AMDResult.MACHINE;
      break;
    case 'fax':
      result = AMDResult.FAX;
      break;
    case 'unknown':
    case 'uncertain':
    case 'unclear':
      result = AMDResult.UNKNOWN;
      break;
    default:
      // Log unknown result but still include it
      console.warn(`[Telnyx AMD] Unknown result type: "${telnyxResult}", mapping to UNKNOWN`);
      result = AMDResult.UNKNOWN;
  }

  // Normalize confidence to 0-1 range (Telnyx may provide 0-100 or 0-1)
  let confidence: number | undefined;
  if (telnyxConfidence !== undefined && telnyxConfidence !== null) {
    if (telnyxConfidence > 1) {
      // Assume 0-100 scale, convert to 0-1
      confidence = Math.min(telnyxConfidence / 100, 1.0);
    } else {
      // Already in 0-1 range
      confidence = Math.max(0, Math.min(telnyxConfidence, 1.0));
    }
  }

  return {
    result,
    confidence,
    rawResult: telnyxResult,
    metadata: {
      automated: true,
      method: 'telnyx_amd'
    }
  };
}

/**
 * Map SignalWire AMD result to unified AMDDetectionResult
 *
 * SignalWire AMD results come via the `AnsweredBy` field in webhooks.
 *
 * Possible results when MachineDetection=Enable:
 * - `human`: Human answered
 * - `machine_start`: Machine detected (quick detection)
 * - `fax`: Fax machine detected
 * - `unknown`: Detection inconclusive
 *
 * Possible results when MachineDetection=DetectMessageEnd:
 * - `human`: Human answered
 * - `machine_end_beep`: Machine detected with beep at end
 * - `machine_end_silence`: Machine detected with silence at end
 * - `machine_end_other`: Machine detected (other)
 * - `fax`: Fax machine detected
 * - `unknown`: Detection inconclusive
 *
 * @param signalWireResult - The SignalWire AnsweredBy string (or AnsweringMachineResult for compatibility)
 * @param signalWireConfidence - The SignalWire confidence number (optional)
 * @returns The unified AMDDetectionResult
 *
 * @example
 * ```typescript
 * const amdResult = mapSignalWireAmdResult('machine_end_beep');
 * console.log(amdResult.result); // 'machine'
 * console.log(amdResult.rawResult); // 'machine_end_beep'
 * ```
 */
export function mapSignalWireAmdResult(
  signalWireResult: string | undefined,
  signalWireConfidence?: number
): AMDDetectionResult | undefined {
  if (!signalWireResult) {
    return undefined;
  }

  const normalizedResult = signalWireResult.toLowerCase().trim();
  let result: AMDResult;

  switch (normalizedResult) {
    case 'human':
    case 'person':
      result = AMDResult.HUMAN;
      break;
    // Machine variants from Enable mode
    case 'machine':
    case 'machine_start':
    case 'voicemail':
    case 'am':
    case 'amd':
    // Machine variants from DetectMessageEnd mode
    case 'machine_end_beep':
    case 'machine_end_silence':
    case 'machine_end_other':
      result = AMDResult.MACHINE;
      break;
    case 'fax':
    case 'fax machine':
      result = AMDResult.FAX;
      break;
    case 'unknown':
    case 'uncertain':
    case 'unclear':
      result = AMDResult.UNKNOWN;
      break;
    default:
      // Log unknown result but still include it
      console.warn(`[SignalWire AMD] Unknown result type: "${signalWireResult}", mapping to UNKNOWN`);
      result = AMDResult.UNKNOWN;
  }

  // Normalize confidence to 0-1 range (SignalWire doesn't typically provide confidence)
  let confidence: number | undefined;
  if (signalWireConfidence !== undefined && signalWireConfidence !== null) {
    if (signalWireConfidence > 1) {
      // Assume 0-100 scale, convert to 0-1
      confidence = Math.min(signalWireConfidence / 100, 1.0);
    } else {
      // Already in 0-1 range
      confidence = Math.max(0, Math.min(signalWireConfidence, 1.0));
    }
  }

  return {
    result,
    confidence,
    rawResult: signalWireResult,
    metadata: {
      automated: true,
      method: 'signalwire_amd',
      // Add detection mode info based on result
      detectionMode: normalizedResult.includes('_end_') ? 'detect_message_end' : 'enable'
    }
  };
}
      automated: true,
      method: 'signalwire_amd'
    }
  };
}

// ============================================================================
// Telnyx Mapper Functions
// ============================================================================

export function mapTelnyxEventToCallEvent(telnyxEvent: TelnyxWebhookEvent): CallEvent {
  const { data } = telnyxEvent;
  const { payload } = data;

  // Extract AMD result using dedicated mapper
  let amdDetectionDetails: AMDDetectionResult | undefined;
  let amdResult: AMDResult | undefined;
  let amdConfidence: number | undefined;

  if (data.event_type === 'call.machine.detection.ended') {
    const result = payload.result || payload.machine_detection_result;
    const confidence = payload.machine_detection_confidence;

    amdDetectionDetails = mapTelnyxAmdResult(result, confidence);
    if (amdDetectionDetails) {
      amdResult = amdDetectionDetails.result;
      amdConfidence = amdDetectionDetails.confidence;
    }
  }

  // Extract recording URL if present
  let recordingUrl: string | undefined;
  if (data.event_type === 'call.recording.saved') {
    recordingUrl =
      payload.public_recording_urls?.mp3 ||
      payload.recording_urls?.mp3 ||
      payload.public_recording_urls?.wav ||
      payload.recording_urls?.wav;
  }

  // Determine hangup reason for completed events
  let hangupReason: HangupReason | undefined;
  if (data.event_type === 'call.hangup') {
    hangupReason = mapTelnyxHangupReason(payload.hangup_cause, payload.hangup_source);
  } else if (data.event_type === 'call.machine.detection.ended' && amdResult === AMDResult.MACHINE) {
    hangupReason = HangupReason.MACHINE_DETECTED;
  }

  return {
    eventId: data.id,
    eventType: mapTelnyxEventType(data.event_type),
    callId: payload.call_control_id,
    sessionId: payload.call_session_id,
    status: payload.state || data.event_type.replace('call.', ''),
    timestamp: new Date(data.occurred_at),
    direction: mapTelnyxDirection(payload.direction),
    from: payload.from,
    to: payload.to,
    provider: 'telnyx',
    durationSecs: payload.recording_duration,
    hangupReason,
    amdResult,
    amdConfidence,
    amdDetectionDetails,
    recordingUrl,
    metadata: {
      callLegId: payload.call_leg_id,
      originalEventType: data.event_type
    },
    rawEvent: telnyxEvent
  };
}

// ============================================================================
// SignalWire Mapper Functions
// ============================================================================

/**
 * Map SignalWire CallStatus to unified CallEventType
 *
 * @param callStatus - The SignalWire CallStatus string
 * @returns The unified CallEventType
 */
function mapSignalWireCallStatus(callStatus: string): CallEventType {
  switch (callStatus.toLowerCase()) {
    case 'queued':
    case 'initiated':
      return CallEventType.INITIATED;
    case 'ringing':
      return CallEventType.RINGING;
    case 'answered':
    case 'in-progress':
      return CallEventType.ANSWERED;
    case 'completed':
      return CallEventType.COMPLETED;
    case 'failed':
    case 'busy':
    case 'no-answer':
    case 'canceled':
      return CallEventType.FAILED;
    default:
      return CallEventType.INITIATED; // Default fallback
  }
}

/**
 * Map SignalWire CallStatus to unified HangupReason
 *
 * @param callStatus - The SignalWire CallStatus string
 * @param hangupBy - The SignalWire HangupBy string (if available)
 * @returns The unified HangupReason
 */
function mapSignalWireHangupReason(callStatus: string, hangupBy?: string): HangupReason {
  // Check hangup source first
  if (hangupBy === 'caller') {
    return HangupReason.CALLER_HANGUP;
  }
  if (hangupBy === 'callee') {
    return HangupReason.CALLEE_HANGUP;
  }

  // Map call status to hangup reason
  switch (callStatus.toLowerCase()) {
    case 'completed':
      return HangupReason.NORMAL;
    case 'no-answer':
      return HangupReason.NO_ANSWER;
    case 'busy':
      return HangupReason.BUSY;
    case 'failed':
      return HangupReason.ERROR;
    case 'canceled':
      return HangupReason.CANCELLED;
    default:
      return HangupReason.UNKNOWN;
  }
}

/**
 * Map SignalWire Direction to unified CallDirection
 *
 * @param direction - The SignalWire Direction string
 * @returns The unified CallDirection
 */
function mapSignalWireDirection(direction: string): CallDirection {
  if (!direction) {
    return CallDirection.OUTBOUND; // Default for outbound dialer app
  }
  return direction.toLowerCase().includes('inbound')
    ? CallDirection.INBOUND
    : CallDirection.OUTBOUND;
}

/**
 * Map a SignalWire status callback to a unified CallEvent
 *
 * @param signalWirePayload - The raw SignalWire status callback payload
 * @returns The normalized CallEvent
 *
 * @example
 * ```typescript
 * const signalWireCallback = {
 *   CallSid: 'CA123456789',
 *   CallStatus: 'in-progress',
 *   From: '+12025551234',
 *   To: '+12025559999',
 *   Direction: 'outbound-api',
 *   AccountSid: 'AC123',
 *   Timestamp: '2024-01-15T10:30:00Z'
 * };
 *
 * const callEvent = mapSignalWireEventToCallEvent(signalWireCallback);
 * console.log(callEvent.eventType); // 'answered'
 * console.log(callEvent.callId); // 'CA123456789'
 * ```
 */
export function mapSignalWireEventToCallEvent(signalWirePayload: SignalWireCallbackPayload): CallEvent {
  const eventType = mapSignalWireCallStatus(signalWirePayload.CallStatus);
  const isTerminalEvent =
    eventType === CallEventType.COMPLETED || eventType === CallEventType.FAILED;

  // Extract AMD result using dedicated mapper
  let amdDetectionDetails: AMDDetectionResult | undefined;
  let amdResult: AMDResult | undefined;
  let amdConfidence: number | undefined;

  if (signalWirePayload.AnsweringMachineResult) {
    amdDetectionDetails = mapSignalWireAmdResult(
      signalWirePayload.AnsweringMachineResult,
      signalWirePayload.AnsweringMachineConfidence
    );
    if (amdDetectionDetails) {
      amdResult = amdDetectionDetails.result;
      amdConfidence = amdDetectionDetails.confidence;
    }
  }

  // Parse duration if available
  let durationSecs: number | undefined;
  if (signalWirePayload.CallDuration) {
    durationSecs = parseInt(signalWirePayload.CallDuration, 10);
    if (isNaN(durationSecs)) {
      durationSecs = undefined;
    }
  }

  // Determine hangup reason for terminal events
  let hangupReason: HangupReason | undefined;
  if (isTerminalEvent) {
    hangupReason = mapSignalWireHangupReason(
      signalWirePayload.CallStatus,
      signalWirePayload.HangupBy
    );
  }

  // Parse timestamp or use current time
  let timestamp: Date;
  if (signalWirePayload.Timestamp) {
    timestamp = new Date(signalWirePayload.Timestamp);
    if (isNaN(timestamp.getTime())) {
      timestamp = new Date();
    }
  } else {
    timestamp = new Date();
  }

  return {
    eventId: `sw-${signalWirePayload.CallSid}-${Date.now()}`,
    eventType,
    callId: signalWirePayload.CallSid,
    sessionId: undefined, // SignalWire doesn't have separate session IDs
    status: signalWirePayload.CallStatus,
    timestamp,
    direction: mapSignalWireDirection(signalWirePayload.Direction),
    from: signalWirePayload.From,
    to: signalWirePayload.To,
    provider: 'signalwire',
    durationSecs,
    hangupReason,
    amdResult,
    amdConfidence,
    amdDetectionDetails,
    recordingUrl: signalWirePayload.RecordingUrl,
    metadata: {
      accountSid: signalWirePayload.AccountSid,
      apiVersion: signalWirePayload.ApiVersion,
      recordingSid: signalWirePayload.RecordingSid,
      originalStatus: signalWirePayload.CallStatus
    },
    rawEvent: signalWirePayload
  };
}

// ============================================================================
// Utility Functions
// ============================================================================

/**
 * Check if a CallEvent represents a terminal state (call has ended)
 *
 * @param event - The CallEvent to check
 * @returns True if the call has ended
 */
export function isTerminalEvent(event: CallEvent): boolean {
  return (
    event.eventType === CallEventType.COMPLETED ||
    event.eventType === CallEventType.FAILED
  );
}

/**
 * Check if a CallEvent represents an active call
 *
 * @param event - The CallEvent to check
 * @returns True if the call is active (answered or in progress)
 */
export function isActiveCall(event: CallEvent): boolean {
  return event.eventType === CallEventType.ANSWERED;
}

/**
 * Get a human-readable description of a CallEvent
 *
 * @param event - The CallEvent to describe
 * @returns A human-readable description
 */
export function describeCallEvent(event: CallEvent): string {
  const direction = event.direction === CallDirection.INBOUND ? 'Inbound' : 'Outbound';
  const parties = event.direction === CallDirection.INBOUND
    ? `from ${event.from} to ${event.to}`
    : `to ${event.to} from ${event.from}`;

  switch (event.eventType) {
    case CallEventType.INITIATED:
      return `${direction} call ${parties} - Dialing`;
    case CallEventType.RINGING:
      return `${direction} call ${parties} - Ringing`;
    case CallEventType.ANSWERED:
      return `${direction} call ${parties} - Connected`;
    case CallEventType.COMPLETED:
      const duration = event.durationSecs ? ` (${event.durationSecs}s)` : '';
      return `${direction} call ${parties} - Completed${duration}`;
    case CallEventType.FAILED:
      const reason = event.hangupReason ? ` - ${event.hangupReason}` : '';
      return `${direction} call ${parties} - Failed${reason}`;
    default:
      return `${direction} call ${parties} - ${event.status}`;
  }
}
